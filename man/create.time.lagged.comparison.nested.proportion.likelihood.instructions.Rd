% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LIKELIHOODS_nested_proportion_likelihood.R
\name{create.time.lagged.comparison.nested.proportion.likelihood.instructions}
\alias{create.time.lagged.comparison.nested.proportion.likelihood.instructions}
\title{Create Time Lagged Comparison Nested Proportion Likelihood Instructions}
\usage{
create.time.lagged.comparison.nested.proportion.likelihood.instructions(
  outcome.for.data,
  denominator.outcome.for.data,
  outcome.for.sim,
  outcome.for.n.multipliers = denominator.outcome.for.data,
  location.types,
  minimum.geographic.resolution.type,
  maximum.locations.per.type = 3,
  dimensions = NULL,
  levels.of.stratification = 0:length(dimensions),
  from.year = -Inf,
  to.year = Inf,
  omit.years = NULL,
  sources.to.use = NULL,
  exclude.denominator.ontology.names = NULL,
  location.overall.keep.threshold = 5,
  location.stratum.keep.threshold = 1,
  p.bias.inside.location,
  p.bias.outside.location,
  p.bias.sd.inside.location,
  p.bias.sd.outside.location,
  within.location.p.error.correlation = 0.5,
  within.location.n.error.correlation = 0.5,
  minimum.error.sd = 0,
  correlation.different.locations = 0,
  correlation.different.years = 0.5,
  correlation.different.strata = 0.1,
  correlation.different.sources = 0.3,
  correlation.same.source.different.details = 0.3,
  obs.n.correlation.different.years = within.location.n.error.correlation,
  observation.correlation.form = c("compound.symmetry", "autoregressive.1")[1],
  n.multiplier.cv = 0.1,
  p.error.variance.term = NULL,
  p.error.variance.type = NULL,
  n.error.variance.term = 0.05,
  n.error.variance.type = "cv",
  n.error.variance.term.if.estimated = 0.8,
  n.error.variance.type.if.estimated = "exp.of.variance",
  ratio.cv = NULL,
  ratio.correlation = NULL,
  weights,
  equalize.weight.by.year = T,
  partitioning.function,
  use.lognormal.approximation = T,
  name = outcome.for.sim
)
}
\arguments{
\item{outcome.for.data}{A single character vector specifying the outcome that data managers will use to find data.}

\item{outcome.for.sim}{A single character vector specifying the simulation outcome to use.}

\item{location.types}{The types of the locations that contain or are contained by the model location. These should be in order of decreasing preference since in the case that two locations have the same contained 'minimum.geographic.resolution.type', such as county "11001" and state "DC", only the higher priority type location will be used.}

\item{minimum.geographic.resolution.type}{The type of location used to partition locations. The type of the model location AND 'location.types' types must all completely enclose regions of this type}

\item{dimensions}{A character vector of dimensions, excluding year, from which stratifications will be generated.}

\item{levels.of.stratification}{An integer vector specifying how the dimensions should be combined to form strata. '0' indicates totals (not stratified) while '1' indicates strata that are each stratified by one dimension at a time, '2' indicates strat that are each stratified by a combination of two dimensions at a time, etc. May not exceed the number of dimensions. Defaults to NULL, which is equivalent to '0'.}

\item{from.year}{-Inf or a single integer value specifying the earliest year for which data should be pulled.}

\item{to.year}{Inf or a single integer value specifying the latest year for which data should be pulled.}

\item{omit.years}{(Optional) An integer vector of years to ignore.}

\item{sources.to.use}{A character vector of sources from which to pull data.}

\item{location.overall.keep.threshold, location.stratum.keep.threshold}{How many data points a location must offer beyond what is found for the main location to justify being retained. Either overall (across ALL strata in total) or on a stratum-by-stratum basis. If a location doesn't meet the overall threshold, it will be ignored entirely. If it does, but fails to meet the stratum threshold for a certain stratum, it will be ignored only in that stratum.}

\item{p.bias.inside.location, p.bias.outside.location, p.bias.sd.inside.location, p.bias.sd.outside.location}{A single numeric value specifying the bias in the outcome proportion between locations inside (or outside) the model location and the model location itself, and their associated standard deviations. Each of these may alternatively be a function that takes only arguments 'version' and 'location' and returns an acceptable numeric value. For the estimates, values should be between -1 and 1, inclusive. For sd, should be non-negative and non-infinite. The bias should = outside/inside location MINUS main location (eg, state - MSA or county - MSA)}

\item{within.location.p.error.correlation, within.location.n.error.correlation}{Single numeric values specifying the correlation between p or n values from the same location and stratum}

\item{minimum.error.sd}{A single, positive numeric value. If any standard deviations are calculated to a value below this, they will be replaced with this value. This can help keep the likelihood from computing to negative infinity.}

\item{correlation.different.locations}{A single numeric value specifying the correlation between observations of different locations.}

\item{correlation.different.years}{A single numeric value specifying the correlation between observations of different years.}

\item{correlation.different.strata}{A single numeric value specifying the correlation between observations from different strata.}

\item{correlation.different.sources}{A single numeric value specifying the correlation between observations from different sources.}

\item{correlation.same.source.different.details}{A single numeric value specifying the correlation between observations of the same source but which have different 'details'.}

\item{obs.n.correlation.different.years}{Single numeric value specifying the correlation between different calculated obs n values}

\item{observation.correlation.form}{Which correlation form to use in building the measurement error covariance matrix. May be 'compound.symmetry' or 'autoregressive.1'.}

\item{n.multiplier.cv}{A single numeric value specifying the covariance term used to find the n.multipliers.}

\item{p.error.variance.type, p.error.variance.term}{The type of error variance(s) to be used for the outcome proportion and the corresponding value or function required for each. See details for the allowable values. For more than one type, supply them in a vector. If you therefore need more than one term, supply these in a list.}

\item{n.error.variance.type}{The 'p.error.variance.type/term' analog for the denominator outcome. Has fewer options of type. See details for more information.}

\item{weights}{A list containing only numeric vectors and objects of class 'jheem.likelihood.weights', which are generated by \code{\link{create.likelihood.weights}}}

\item{equalize.weight.by.year}{A Boolean indicating whether every year should be weighted equally before the weights from 'weights' are applied.}

\item{partitioning.function}{A function that partitions values in the data ontology into values in the model ontology. Must have two arguments, "arr" and "version" and return an array with the same dimnames as the input array.}

\item{use.lognormal.approximation}{A single logical value.}
}
\description{
Create Time Lagged Comparison Nested Proportion Likelihood Instructions
}
\details{
P error variance may be specified in a variety of ways, and more
than one can be used in the same likelihood. 'error.variance.type' is a
vector containing single character values describing the type(s) of variance
to use, and there is one 'error.variance.term' corresponding to each. The
types "sd" (standard deviation), "variance", "cv" (covariance), and
"exp.of.variance" (exponent of variance) require a single numeric value as
their term. The types "data.sd", "data.variance", and "data.cv" indicate that
error data will be pulled from the data manager and matched directly to data
points, and they require NULL as their term. Finally, the type "function.sd"
requires as its term a function that takes only arguments "data",
"details", "version", and "location" and returns a numeric array of the same dimensions as "data".
Supplying multiple types (and therefore terms) results in the variances
created by each being summed prior to use in the measurement error covariance
matrix.

As an example, one type could be specified with a 'p.error.variance.type' of
"cv" and a 'p.error.variance.term' of 0.13 (or list(0.13)). Two or more
types might look like a 'p.error.variance.type' of `c("data.sd",
"function.sd") and a 'p.error.variance.term' of list(NULL, my_sd_function).
It is possible to use the same type multiple times, although this is not
recommended.

N error variance works the same way but only one type is currently supported:
"cv" (covariance).
}
\seealso{
Other Nested Proportion Likelihoods: 
\code{\link{create.nested.proportion.likelihood.instructions.with.included.multiplier}()},
\code{\link{create.nested.proportion.likelihood.instructions}()},
\code{\link{get.p.bias.estimates}()}
}
\concept{Nested Proportion Likelihoods}
