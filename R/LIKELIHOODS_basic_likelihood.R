
#'
#'@param outcome.for.data A single character vector specifying the outcome that data managers will use to find data.
#'@param outcome.for.sim A single character vector specifying the simulation outcome to use.
#'@param denominator.outcome.for.sim (Optional) A single character vector specifying the simulation outcome to use a denominator if the outcome.for.sim is a ratio, proportion, or rate.
#'@param dimensions A character vector of dimensions, excluding year, from which stratifications will be generated.
#'@param denominator.dimensions (Optional) Analogous to 'dimensions' but for the simulation denominator outcome when applicable. Must be a subset of 'dimensions'.
#'@param levels.of.stratification An integer vector specifying how the dimensions should be combined to form strata. '0' indicates totals (not stratified) while '1' indicates strata that are each stratified by one dimension at a time, '2' indicates strat that are each stratified by a combination of two dimensions at a time, etc. May not exceed the number of dimensions. Defaults to NULL, which is equivalent to '0'.
#'@param from.year -Inf or a single integer value specifying the earliest year for which data should be pulled.
#'@param to.year Inf or a single integer value specifying the latest year for which data should be pulled.
#'@param omit.years (Optional) An integer vector of years to ignore.
#'@param sources.to.use A character vector of sources from which to pull data.
#'@param correlation.different.years A single numeric value specifying the correlation between observations of different years.
#'@param correlation.different.strata A single numeric value specifying the correlation between observations from different strata.
#'@param correlation.different.sources A single numeric value specifying the correlation between observations from different sources.
#'@param correlation.same.source.different.details A single numeric value specifying the correlation between observations of the same source but which have different 'details'.
#'@param observation.correlation.form Which correlation form to use in building the measurement error covariance matrix. May be 'compound.symmetry' or 'autoregressive.1'.
#'@param measurement.error.coefficient.of.variance A single numeric value specyfing the coefficient of variance used to build the measurement error covariance matrix.
#'@param weights A list containing only numeric vectors and objects of class 'jheem.likelihood.weights', which are generated by \code{\link{create.likelihood.weights}}
#'@param equalize.weight.by.year A Boolean indicating whether every year should be weighted equally before the weights from 'weights' are applied.
#'
#'@export
create.basic.likelihood.instructions <- function(outcome.for.data,
                                                 outcome.for.sim,
                                                 denominator.outcome.for.sim = NULL, # If NULL (as it would be for population), will be doing the Poisson version of compute. OR, if outcome is proportion, rate, or time, use denominator within sim data
                                                 dimensions = character(0),
                                                 denominator.dimensions = dimensions,
                                                 dimension.values = NULL, # EXPERIMENTAL
                                                 levels.of.stratification = NULL,
                                                 from.year = -Inf,
                                                 to.year = Inf,
                                                 omit.years = NULL,
                                                 sources.to.use = NULL,
                                                 correlation.different.years = 0.5,
                                                 correlation.different.strata = 0.1,
                                                 correlation.different.sources = 0.3,
                                                 correlation.same.source.different.details = 0.3,
                                                 observation.correlation.form = c('compound.symmetry', 'autoregressive.1')[1],
                                                 measurement.error.coefficient.of.variance,
                                                 weights = list(),
                                                 equalize.weight.by.year = T)
{
    
    create.basic.likelihood.instructions.with.included.multiplier(outcome.for.data = outcome.for.data,
                                                                  outcome.for.sim = outcome.for.sim,
                                                                  denominator.outcome.for.sim = denominator.outcome.for.sim,
                                                                  dimensions = dimensions,
                                                                  denominator.dimensions = denominator.dimensions,
                                                                  dimension.values = dimension.values, # EXPERIMENTAL
                                                                  levels.of.stratification = levels.of.stratification,
                                                                  from.year = from.year,
                                                                  to.year = to.year,
                                                                  omit.years = omit.years,
                                                                  sources.to.use = sources.to.use,
                                                                  included.multiplier=NULL,
                                                                  included.multiplier.sd=NULL,
                                                                  included.multiplier.correlation=NULL,
                                                                  correlation.different.years = correlation.different.years,
                                                                  correlation.different.strata = correlation.different.strata,
                                                                  correlation.different.sources = correlation.different.sources,
                                                                  correlation.same.source.different.details = correlation.same.source.different.details,
                                                                  observation.correlation.form = observation.correlation.form,
                                                                  measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance,
                                                                  weights = weights,
                                                                  equalize.weight.by.year = equalize.weight.by.year
        
    )
    
}

create.basic.likelihood.instructions.with.included.multiplier <- function(outcome.for.data,
                                                                          outcome.for.sim,
                                                                          denominator.outcome.for.sim=NULL,
                                                                          dimensions = character(0),
                                                                          denominator.dimensions = dimensions,
                                                                          dimension.values = NULL, # EXPERIMENTAL
                                                                          levels.of.stratification = NULL,
                                                                          from.year = -Inf,
                                                                          to.year = Inf,
                                                                          omit.years = NULL,
                                                                          sources.to.use = NULL,
                                                                          included.multiplier,
                                                                          included.multiplier.sd,
                                                                          included.multiplier.correlation=NULL,
                                                                          included.multiplier.correlation.structure=c('compound.symmetry', 'autoregressive.1')[1],
                                                                          correlation.different.years = 0.5,
                                                                          correlation.different.strata = 0.1,
                                                                          correlation.different.sources = 0.3,
                                                                          correlation.same.source.different.details = 0.3,
                                                                          observation.correlation.form = c('compound.symmetry', 'autoregressive.1')[1],
                                                                          measurement.error.coefficient.of.variance,
                                                                          weights = list(),
                                                                          equalize.weight.by.year = T)
{
    JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS$new(outcome.for.data = outcome.for.data,
                                            outcome.for.sim = outcome.for.sim,
                                            denominator.outcome.for.sim = denominator.outcome.for.sim,
                                            dimensions = dimensions,
                                            denominator.dimensions = denominator.dimensions,
                                            dimension.values = dimension.values, # EXPERIMENTAL
                                            levels.of.stratification = levels.of.stratification,
                                            from.year = from.year,
                                            to.year = to.year,
                                            omit.years = omit.years,
                                            sources.to.use = sources.to.use,
                                            included.multiplier=included.multiplier,
                                            included.multiplier.sd=included.multiplier.sd,
                                            included.multiplier.correlation=included.multiplier.correlation,
                                            included.multiplier.correlation.structure=included.multiplier.correlation.structure,
                                            correlation.different.years = correlation.different.years,
                                            correlation.different.strata = correlation.different.strata,
                                            correlation.different.sources = correlation.different.sources,
                                            correlation.same.source.different.details = correlation.same.source.different.details,
                                            observation.correlation.form = observation.correlation.form,
                                            measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance,
                                            weights = weights,
                                            equalize.weight.by.year = equalize.weight.by.year)
}

JHEEM.BASIC.LIKELIHOOD.INSTRUCTIONS = R6::R6Class(
    'jheem.basic.likelihood.instructions',
    inherit = JHEEM.LIKELIHOOD.INSTRUCTIONS,
    
    public = list(
        
        initialize = function(outcome.for.data,
                              outcome.for.sim,
                              denominator.outcome.for.sim,
                              dimensions,
                              denominator.dimensions,
                              dimension.values, # EXPERIMENTAL
                              levels.of.stratification,
                              from.year,
                              to.year,
                              omit.years,
                              sources.to.use,
                              included.multiplier,
                              included.multiplier.sd,
                              included.multiplier.correlation,
                              included.multiplier.correlation.structure,
                              correlation.different.years,
                              correlation.different.strata,
                              correlation.different.sources,
                              correlation.same.source.different.details,
                              observation.correlation.form,
                              measurement.error.coefficient.of.variance,
                              weights,
                              equalize.weight.by.year)
        {
            
            
            error.prefix = paste0('Error creating basic likelihood instructions: ')
            
            # *outcome.for.sim* -- validated in the super$initialize
            
            # *outcome.for.data* is a single character vector
            if (!is.character(outcome.for.data) || length(outcome.for.data) > 1 || is.null(outcome.for.data) || is.na(outcome.for.data))
                stop(paste0(error.prefix, "'outcome.for.data' must be a character vector of length 1"))
            
            # *denominator.outcome.for.sim* is NULL or a single character vector
            if (!is.null(denominator.outcome.for.sim) && (!is.character(denominator.outcome.for.sim) || length(denominator.outcome.for.sim) > 1 || is.na(denominator.outcome.for.sim)))
                stop(paste0(error.prefix, "'denominator.outcome.for.sim' must be NULL or a character vector of length 1"))
            
            # *dimensions* -- validated in the super$initialize
            
            # *denominator.dimensions* is NULL or a character vector with no NAs or duplicates
            # AND which is a subset of *dimensions*
            if (!is.null(denominator.dimensions) && (!is.character(denominator.dimensions) || any(is.na(denominator.dimensions)) || any(duplicated(dimensions))) || length(setdiff(denominator.dimensions, dimensions)) > 0)
                stop(paste0(error.prefix, "'denominator dimensions' must be NULL or a character vector with no NAs or duplicates that is a subset of 'dimensions'"))
            
            # *levels.of.stratification* -- validated in the super$initialize
            
            # *from.year* and *to.year* are single integer vectors. *to.year* must be larger than *from.year*.
            if (from.year != -Inf && (!is.numeric(from.year) || length(from.year) > 1 || is.null(from.year) || is.na(from.year)))
                stop(paste0(error.prefix, "'from.year' must be -Inf or a numeric vector of length 1"))
            if (to.year != Inf && (!is.numeric(to.year) || length(to.year) > 1 || is.null(to.year) || is.na(to.year)))
                stop(paste0(error.prefix, "'to.year' must be Inf or a numeric vector of length 1"))
            if (from.year > to.year)
                stop(paste0(error.prefix, "'from.year' must be less than 'to.year'"))
            
            # *omit.years* is NULL or a numeric vector containing no NAs or duplicates.
            if (!is.null(omit.years) && (!is.numeric(omit.years) || any(is.na(omit.years)) || any(duplicated(omit.years))))
                stop(paste0(error.prefix, "'omit.years' must be NULL or an numeric vector containing no NAs or duplicates"))
            omit.years = as.integer(omit.years)
            
            # *sources.to.use* is NULL or a character vector containing no NAs or duplicates
            if (!is.null(sources.to.use) && (!is.character(sources.to.use) || any(is.na(sources.to.use)) || any(duplicated(sources.to.use))))
                stop(paste0(error.prefix, "'sources.to.use' must be NULL or a character vector containing no NAs or duplicates"))
            
            # *included.multiplier* is NULL, a single numeric value, or a named numeric vector with names corresponding to years or year ranges.
            if (!is.null(included.multiplier) &&
                (!is.numeric(included.multiplier) || length(included.multiplier)!=1 || is.na(included.multiplier) || included.multiplier<=0) &&
                (!is.numeric(included.multiplier) || is.null(names(included.multiplier)) || any(is.na(included.multiplier)) || any(included.multiplier<=0) || is.null(parse.year.names(names(included.multiplier)))))
                stop(paste0(error.prefix, "'included.multiplier' must be one of: 1. NULL, 2. a single, non-NA, numeric value greater than 0, or 3. a named numeric vector with all values non-NA and greater than zero and names all corresponding to years or year ranges"))
            
            # *included.multiplier.sd* is NULL, a single numeric value, or a named numeric vector with the same names as *included.multiplier*.
            if (!is.null(included.multiplier.sd) &&
                (!is.numeric(included.multiplier.sd) || length(included.multiplier.sd)!= 1 || is.na(included.multiplier.sd) || included.multiplier.sd<=0) &&
                (!is.numeric(included.multiplier.sd) || any(is.na(included.multiplier.sd)) || any(included.multiplier.sd<=0) || !identical(names(included.multiplier.sd), names(included.multiplier))))
                stop(paste0(error.prefix, "'included.multiplier.sd' must be one of: 1. NULL, 2. a single, non-NA, numeric value greater than 0, or 3. a named numeric vector with all values non-NA and greater than zero and the same names as 'included.multiplier'"))
            # and cannot be NULL if *included.multiplier* is not NULL
            if (!is.null(included.multiplier) && is.null(included.multiplier.sd))
                stop(paste0(error.prefix, "'included.multiplier.sd' cannot be NULL if 'included.multiplier' is not also NULL"))
            
            # *included.multiplier.correlation* is NULL or a single numeric value between 0 and 1.
            if (!is.null(included.multiplier.correlation) &&
                (!is.numeric(included.multiplier.correlation) || length(included.multiplier.correlation)!=1 || included.multiplier.correlation <=0 || included.multiplier.correlation >= 1))
                stop(paste0(error.prefix, "'included.multiplier.correlation' must be NULL or a single numeric value between 0 and 1"))
            # and cannot be NULL if *included.multiplier* is not NULL
            if (!is.null(included.multiplier) && is.null(included.multiplier.correlation))
                stop(paste0(error.prefix, "''included.multiplier.correlation' cannot be NULL if 'included.multiplier' is not also NULL"))
            
            # *included.multiplier.correlation.structure* is 'compound.symmetry' or 'autoregressive.1'
            if (!is.character(included.multiplier.correlation.structure) || length(included.multiplier.correlation.structure)!=1 || !(included.multiplier.correlation.structure) %in% c('compound.symmetry', 'autoregressive.1'))
                stop(paste0(error.prefix, "'included.multiplier.correlation.structure' must be either 'compound.symmetry' or 'autoregressive.1'"))
            
            # *correlation.multipliers* are all single numeric vectors with values between 0 and 1 inclusive
            correlation.multipliers = list(correlation.different.years=correlation.different.years,
                                           correlation.different.strata=correlation.different.strata,
                                           correlation.different.sources=correlation.different.sources,
                                           correlation.same.source.different.details=correlation.same.source.different.details)
            names(correlation.multipliers) = c(correlation.different.years, correlation.different.strata, correlation.different.sources, correlation.same.source.different.details)
            for (i in seq_along(correlation.multipliers)) {
                if (!is.numeric(correlation.multipliers[[i]]) || length(correlation.multipliers[[i]]) > 1 || is.na(correlation.multipliers[[i]]) || correlation.multipliers[[i]] > 1 || correlation.multipliers[[i]] < 0)
                    stop(paste0(error.prefix, "'", names(correlation.multipliers)[[i]], "' must be a numeric value between 0 and 1 inclusive"))
            }
            
            # *observation.correlation.form* is either 'compound.symmetry' or 'autoregressive.1'
            if (length(observation.correlation.form) > 1 || !(observation.correlation.form %in% c('compound.symmetry', 'autoregressive.1')))
                stop(paste0(error.prefix, "'observation.correlation.form' must be either 'compound.symmetry' or 'autoregressive.1'"))
            
            # *measurement.error.coefficient.of.variance* must be a single numeric value between 0 and 1
            if (!is.numeric(measurement.error.coefficient.of.variance) || length(measurement.error.coefficient.of.variance) > 1 || is.na(measurement.error.coefficient.of.variance) || measurement.error.coefficient.of.variance > 1 || measurement.error.coefficient.of.variance < 0)
                stop(paste0(error.prefix, "'measurement.error.coefficient.of.variance' must be a numeric value between 0 and 1 inclusive"))
            
            # *weights* -- validated in the super$initialize
            
            # *equalize.weight.by.year* is a boolean
            if (!is.logical(equalize.weight.by.year) || length(equalize.weight.by.year) > 1 || is.null(equalize.weight.by.year) || is.na(equalize.weight.by.year))
                stop(paste0(error.prefix, "'equalize.weight.by.year' must be a single logical value (T/F)"))
            
            # EXPERIMENTAL DIMENSION VALUES SHOULD BE A NAMED LIST
            if (!is.null(dimension.values) && (!is.list(dimension.values) || (length(dimension.values > 0) && is.null(names(dimension.values))) || 'year' %in% names(dimension.values)))
                stop(paste0(error.prefix, "experimental 'dimension.values' argument must be NULL or a named list without 'year'"))
            
            super$initialize(outcome.for.sim = outcome.for.sim,
                             dimensions = dimensions,
                             levels.of.stratification = levels.of.stratification,
                             weights = weights,
                             likelihood.class.generator = JHEEM.BASIC.LIKELIHOOD,
                             error.prefix = error.prefix)
            
            private$i.outcome.for.data = outcome.for.data
            private$i.denominator.outcome.for.sim = denominator.outcome.for.sim
            private$i.from.year = from.year
            private$i.to.year = to.year
            private$i.omit.years = omit.years
            private$i.denominator.dimensions = denominator.dimensions
            private$i.equalize.weight.by.year = equalize.weight.by.year
            private$i.sources.to.use = sources.to.use
            private$i.parameters = list(included.multiplier = included.multiplier,
                                        included.multiplier.sd = included.multiplier.sd,
                                        included.multiplier.correlation = included.multiplier.correlation,
                                        included.multiplier.correlation.structure = included.multiplier.correlation.structure,
                                        correlation.different.years = correlation.different.years,
                                        correlation.different.strata = correlation.different.strata,
                                        correlation.different.sources = correlation.different.sources,
                                        correlation.same.source.different.details = correlation.same.source.different.details,
                                        observation.correlation.form = observation.correlation.form,
                                        measurement.error.coefficient.of.variance = measurement.error.coefficient.of.variance)
            private$i.dimension.values = dimension.values # EXPERIMENTAL
        },
        
        equals = function(other)
        {
            if (!is(other, 'jheem.likelihood.instructions'))
                stop("'other' must be a 'jheem.likelihood.instructions' object")
            if (!is.null(self$code) && !is.null(other$code))
                self$code == other$code
            else {
                if (is(other, 'jheem.basic.likelihood.instructions'))
                {
                    to.compare.identical = c('description',
                                             'outcome.for.data',
                                             'outcome.for.sim',
                                             'denominator.outcome.for.sim',
                                             'from.year',
                                             'to.year')
                    to.compare.setequal = c('sources.to.use',
                                            'omit.years',
                                            'denominator.dimensions')
                    
                    all(sapply(to.compare.identical, function(x) {
                        identical(self[[x]], other[[x]])
                    })) &&
                        all(sapply(to.compare.setequal, function(x) {
                            setequal(self[[x]], other[[x]])
                        })) &&
                        all(sapply(self$weights, function(x) {any(sapply(other$weights, function(y) {
                                x$equals(y)
                            }))})) &&
                        all(sapply(names(self$parameters), function(x) {
                            self$parameters[[x]] == other$parameters[[x]]
                        })) &&
                        private$stratification.lists.equal(self$stratifications, other$stratifications)
                } else F
            }
        }
    ),
    
    active = list(
        
        outcome.for.data = function(value)
        {
            if (missing(value))
            {
                private$i.outcome.for.data
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'outcome.for.data' - it is read-only")
        },
        denominator.outcome.for.sim = function(value)
        {
            if (missing(value))
            {
                private$i.denominator.outcome.for.sim
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'denominator.outcome.for.sim' - it is read-only")
        },
        from.year = function(value)
        {
            if (missing(value))
            {
                private$i.from.year
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'from.year' - it is read-only")
        },
        to.year = function(value)
        {
            if (missing(value))
            {
                private$i.to.year
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'to.year' - it is read-only")
        },
        omit.years = function(value)
        {
            if (missing(value))
            {
                private$i.omit.years
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'omit.years' - they are read-only")
        },
        denominator.dimensions = function(value)
        {
            if (missing(value))
            {
                private$i.denominator.dimensions
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'denominator.dimensions' - they are read-only")
        },
        equalize.weight.by.year = function(value)
        {
            if (missing(value))
            {
                private$i.equalize.weight.by.year
            }
            else
                stop("Cannot modify a jheem.likelihood.instruction's 'equalize.weight.by.year' - it is read-only")
        },
        parameters = function(value)
        {
            if (missing(value)) {
                private$i.parameters
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'parameters' - they are read-only")
        },
        sources.to.use = function(value)
        {
            if (missing(value)) {
                private$i.sources.to.use
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's 'sources.to.use' - they are read-only")
        },
        
        dimension.values = function(value) # EXPERIMENTAL
        {
            if (missing(value)) {
                private$i.dimension.values
            }
            else
                stop("Cannot modify a jheem.basic.likelihood.instruction's experimental 'dimension.values' - they are read-only")
        }
        
    ),
    
    private = list(
        i.outcome.for.data = NULL,
        i.denominator.outcome.for.sim = NULL,
        i.from.year = NULL,
        i.to.year = NULL,
        i.omit.years = NULL,
        i.denominator.dimensions = NULL,
        i.equalize.weight.by.year = NULL,
        i.parameters = NULL,
        i.sources.to.use = NULL,
        i.dimension.values = NULL # EXPERIMENTAL
    )
)

# class generator object
JHEEM.BASIC.LIKELIHOOD = R6::R6Class(
    'jheem.basic.likelihood',
    inherit = JHEEM.LIKELIHOOD,
    portable = F,
    
    public = list(
        
        initialize = function(instructions,
                              version,
                              location, #combinations of version and location tell us sublocations
                              sub.version,
                              data.manager,
                              throw.error.if.no.data,
                              error.prefix)
        {
            # browser()
            super$initialize(instructions = instructions,
                             sub.version = sub.version,
                             version = version,
                             location = location,
                             error.prefix = error.prefix)

            # Validate *data.manager*, a 'jheem.data.manager' object
            if (!R6::is.R6(data.manager) || !is(data.manager, 'jheem.data.manager'))
                stop(paste0(error.prefix, "'data.manager' must be an R6 object with class 'jheem.data.manager'"))
            
            private$i.parameters = instructions$parameters
            private$i.outcome.for.data = instructions$outcome.for.data
            private$i.denominator.outcome.for.sim = instructions$denominator.outcome.for.sim
            
            private$i.dimension.values = instructions$dimension.values # EXPERIMENTAL

            ## ---- DETERMINE YEARS FOR SIM METADATA ---- ##
            years = get.likelihood.years(from.year = instructions$from.year,
                                         to.year = instructions$to.year,
                                         omit.years = instructions$omit.years,
                                         data.manager = data.manager,
                                         outcome.for.data = private$i.outcome.for.data)
            
            ## ---- PREPARE DATA STRUCTURES ---- ##
            
            sim.metadata = get.simulation.metadata(version=version, ## MOVE THIS TO MAIN LIKELIHOOD SINCE ALL WILL HAVE SIM METADATA?
                                                   location=location,
                                                   from.year = years[[1]],
                                                   to.year = years[[length(years)]])
            
            if(!is.null(private$i.denominator.outcome.for.sim) && !(private$i.denominator.outcome.for.sim %in% sim.metadata$outcomes))
                stop(paste0(error.prefix, private$i.denominator.for.sim, " is not a simulation outcome in this specification"))

            scale = sim.metadata$outcome.metadata[[private$i.outcome.for.sim]]$scale
            if (!(scale %in% c('non.negative.number', 'number', 'proportion')))
                stop(paste0(error.prefix, "'outcome.for.sim' must be a non.negative.number, number, or proportion"))
            private$i.outcome.is.proportion = scale == 'proportion'
            
            if (private$i.outcome.is.proportion && is.null(private$i.denominator.outcome.for.sim)) {
                private$i.denominator.outcome.for.sim = sim.metadata$outcome.metadata[[private$i.outcome.for.sim]]$denominator.outcome
                if (is.null(private$i.denominator.outcome.for.sim))
                    stop(paste0(error.prefix, "denominator data expected for this outcome but not found"))
            }

            private$i.sim.ontology = sim.metadata$outcome.ontologies[[private$i.outcome.for.sim]]
            private$i.sim.ontology$year = as.character(years)
            private$i.sim.ontology = do.call(ontology, c(private$i.sim.ontology, list(incomplete.dimensions = c('year', 'location'))))
            
            # Validate that instructions asked for dimensions that are in sim ontology for this outcome, and no more.
            requested.dimensions = setdiff(unique(unlist(private$i.stratifications)), "")
            dimensions.in.instr.not.sim = requested.dimensions[!sapply(requested.dimensions, function(d) {d %in% names(private$i.sim.ontology)})]
            if (length(dimensions.in.instr.not.sim) > 0)
                stop(paste0(error.prefix, "likelihood instructions requested the following dimensions not present in the simulation ontology for this outcome: ", paste(dimensions.in.instr.not.sim, collapse=", ")))
            
            
            private$i.obs.vector = c()
            private$i.details = c() # will contain each observation's sorted details as a collapsed character factor
            private$i.metadata = data.frame(year = character(0),
                                            stratum = character(0),
                                            source = character(0))

            dimnames.list = list()
            remove.mask.list = list()
            dv.remove.mask.list = list() # EXPERIMENTAL
            private$i.transformation.matrix = NULL
            private$i.sim.required.dimnames = list()
            
            ### EXPERIMENTAL: LIMIT STRATIFICATIONS TO ONLY THOSE WITH *ALL* THE DIMENSIONS FROM DIMENSION VALUES
            if (length(private$i.dimension.values) > 0) {
                private$i.stratifications = private$i.stratifications[sapply(private$i.stratifications, function(stratification) {setequal(stratification, names(private$i.dimension.values))})]
            }

            ## ---- PULL DATA ---- ##

            n.stratifications.with.data = 0
            for (strat in private$i.stratifications) {
                keep.dimensions = 'year'
                if (!identical(strat, "")) keep.dimensions = c(keep.dimensions, strat)
                data = data.manager$pull(outcome = private$i.outcome.for.data,
                                         sources = instructions$sources.to.use,
                                         keep.dimensions = keep.dimensions,
                                         dimension.values = list(year = as.character(years), location=location), # leave this for now. Will get more complicated when we have multi location models
                                         target.ontology = private$i.sim.ontology,
                                         allow.mapping.from.target.ontology = T,
                                         append.attributes = 'details',
                                         debug = F)
                
                if (is.null(data)) {
                    if (throw.error.if.no.data)
                        stop(paste0(error.prefix, "no data was found for the stratification '", strat, "'"))
                    else next
                }
                n.stratifications.with.data = n.stratifications.with.data + 1
                one.mapping = attr(data, 'mapping')
                one.dimnames = dimnames(data)
                one.obs.vector = as.numeric(data)
                one.details = attr(data, 'details')
                
                # EXPERIMENTAL
                one.dimension.values.remove.mask = rep(T, length(one.obs.vector)) # EXPERIMENTAL
                one.dimension.values.remove.mask[get.array.access.indices(one.dimnames, dimension.values=private$i.dimension.values)] = F # EXPERIMENTAL
                dv.remove.mask.list = c(dv.remove.mask.list, list(one.dimension.values.remove.mask)) # EXPERIMENTAL

                one.remove.mask = is.na(one.obs.vector)
                one.obs.vector = one.obs.vector[!one.remove.mask]
                one.details = one.details[!one.remove.mask]
                
                # Metadata will involve melting both arrays (data and details) as well as making "stratum"
                one.metadata = reshape2::melt(data)  
                one.metadata = one.metadata[!one.remove.mask,]
                
                # Recover required dimnames from one.metadata
                one.sim.required.dimnames = one.mapping$get.required.from.dim.names(lapply(one.metadata[!(colnames(one.metadata) %in% c('source', 'value'))],
                                                                                       function(x) {as.character(unique(x))}))
                
                one.metadata = one.metadata[, sort(colnames(one.metadata))]
                one.metadata['stratum'] = do.call(paste, c(subset.data.frame(one.metadata, select=-c(year, source, value)), sep="__"))
                one.metadata[is.na(one.metadata$stratum), 'stratum'] = ".TOTAL."
                one.metadata = subset.data.frame(one.metadata, select = c(year, stratum, source))
                
                # Find the required.dimnames
                for (d in names(one.sim.required.dimnames)) {
                    if (!(d %in% names(private$i.sim.required.dimnames)))
                        private$i.sim.required.dimnames = c(private$i.sim.required.dimnames, setNames(list(one.sim.required.dimnames[[d]]), d))
                    else
                        private$i.sim.required.dimnames[[d]] = union(private$i.sim.required.dimnames[[d]], one.sim.required.dimnames[[d]])
                }
                
                # Convert one.details list of vectors to a list of characters of collapsed sorted details, then unlist to a vector
                one.details = unlist(lapply(one.details, function(v) {paste(sort(v), collapse="__")}))

                private$i.obs.vector = c(private$i.obs.vector, one.obs.vector)
                private$i.details = c(private$i.details, one.details)
                private$i.metadata = rbind(private$i.metadata, one.metadata)
                dimnames.list = c(dimnames.list, list(one.dimnames))
                remove.mask.list = c(remove.mask.list, list(one.remove.mask))
                
            }
            
            if (n.stratifications.with.data==0)
                stop(paste0(error.prefix, "No data found for any stratifications"))

            # NOTE: STRATUM MUST BE RESTORED TO CHARACTER LATER WHEN WE GENERATE THE WEIGHTS MATRIX SINCE WE HAVE TO STRING SPLIT IT
            private$i.details = as.factor(private$i.details)
            # private$i.metadata$location = as.factor(private$i.metadata$location) # already factor somehow
            if (private$i.parameters$observation.correlation.form == 'autoregressive.1') {
                private$i.metadata$year = suppressWarnings(as.numeric(private$i.metadata$year))
                if (any(is.na(private$i.metadata$year)))
                    stop(paste0(error.prefix, "'observation.correlation.form' 'autoreggresive.1' can only be used with single-year data points"))
            }
            else private$i.metadata$year = as.factor(private$i.metadata$year)
            private$i.metadata$stratum = as.factor(private$i.metadata$stratum)
            # private$i.metadata$source = as.factor(private$i.metadata$source) # already factor somehow
            
            ## ---- FIND REQUIRED DIMENSION VALUES, ETC. ---- ##
            corrected.sim.required.dimnames = private$i.sim.ontology[names(private$i.sim.ontology) %in% names(private$i.sim.required.dimnames)]
            corrected.sim.required.dimnames$year = private$i.sim.required.dimnames$year
            private$i.sim.required.dimnames = corrected.sim.required.dimnames
            
            private$i.years = private$i.sim.required.dimnames[['year']]
            private$i.sim.dimension.values = private$i.sim.required.dimnames[sapply(names(private$i.sim.required.dimnames), function(d) {!identical(private$i.sim.required.dimnames[[d]], private$i.sim.ontology[[d]])})]
            private$i.sim.dimension.values[['year']] = private$i.years
            
            denominator.keep.dimensions = c(instructions$denominator.dimensions, 'year')[c(instructions$denominator.dimensions, 'year') %in% names(private$i.sim.required.dimnames)]
            private$i.denominator.required.dimnames = private$i.sim.required.dimnames[names(private$i.sim.required.dimnames) %in% denominator.keep.dimensions]
            private$i.denominator.dimension.values = private$i.denominator.required.dimnames[sapply(names(private$i.denominator.required.dimnames), function(d) {!identical(private$i.denominator.required.dimnames[[d]], private$i.sim.ontology[[d]])})]
            private$i.denominator.dimension.values[['year']] = private$i.years

            ## ---- GENERATE TRANSFORMATION MATRIX ---- ##
            private$i.transformation.matrix = generate.transformation.matrix(dimnames.list, remove.mask.list, n.stratifications.with.data, private$i.sim.required.dimnames)
            
            if (is.null(private$i.transformation.matrix))
                stop(paste0(error.prefix, "no mappings found to align simulation and data ontologies"))
            
            ## ---- EXPERIMENTAL: CREATE DIMENSION VALUES MASK ---- ##
            # APPLY IT TO TRANSFORMATION MATRIX, OBS VECTOR, METADATA
            dv.shortened.remove.mask = unlist(dv.remove.mask.list)[!unlist(remove.mask.list)]
            private$i.transformation.matrix = private$i.transformation.matrix[!dv.shortened.remove.mask,]
            private$i.obs.vector = private$i.obs.vector[!dv.shortened.remove.mask]
            private$i.metadata = private$i.metadata[!dv.shortened.remove.mask,]
            
            ## ---- GENERATE SPARSE REPRESENTATIONS OF TRANSFORMATION MATRIX ---- ##
            private$i.transformation.matrix.indices = generate_transformation_matrix_indices(private$i.transformation.matrix,
                                                                                             length(private$i.obs.vector),
                                                                                             length(private$i.transformation.matrix) / length(private$i.obs.vector))

            private$i.transformation.matrix.row.oriented.indices = generate_transformation_matrix_row_oriented_indices(private$i.transformation.matrix,
                                                                                                                       length(private$i.obs.vector),
                                                                                                                       length(private$i.transformation.matrix) / length(private$i.obs.vector))

            ## ---- GENERATE MEASUREMENT ERROR COVARIANCE MATRIX ---- ##

            # call this function with numeric(0) replacing the locations vector and 1 replacing the correlation different locations, used in the nested proportion likelihood.
            n.obs = length(private$i.obs.vector)
            measurement.error.correlation.matrix = get_obs_error_correlation_matrix(rep(1, n.obs**2),
                                                                                    n.obs,
                                                                                    numeric(0),
                                                                                    as.numeric(private$i.metadata$year),
                                                                                    as.numeric(private$i.metadata$stratum),
                                                                                    as.numeric(private$i.metadata$source),
                                                                                    as.numeric(private$i.details),
                                                                                    1,
                                                                                    private$i.parameters$correlation.different.year,
                                                                                    private$i.parameters$correlation.different.strata,
                                                                                    private$i.parameters$correlation.different.source,
                                                                                    private$i.parameters$correlation.same.source.different.details,
                                                                                    private$i.parameters$observation.correlation.form == "autoregressive.1")
            measurement.error.sd = private$i.obs.vector * private$i.parameters$measurement.error.coefficient.of.variance
            
            private$i.measurement.error.covariance.matrix =
                measurement.error.correlation.matrix * (measurement.error.sd %*% t(measurement.error.sd))
            
            ## included multiplier to make inverse multiplier matrix times covariance matrix
            if (!is.null(private$i.parameters$included.multiplier)) {
                
                if (!is.null(names(private$i.parameters$included.multiplier))) {
                    
                    if (any(!(private$i.metadata$year %in% names(private$i.parameters$included.multiplier))))
                        stop(paste0(error.prefix, "all years values in data must have a corresponding 'included.multiplier'"))
                    
                    included.multiplier.vector = sapply(private$i.metadata$year, function(obs.year) {private$i.parameters$included.multiplier[obs.year]})
                    included.multiplier.sd.vector = sapply(private$i.metadata$year, function(obs.year) {private$i.parameters$included.multiplier.sd[obs.year]})
                }
                else {
                    included.multiplier.vector = rep(private$i.parameters$included.multiplier, n.obs)
                    included.multiplier.sd.vector = rep(private$i.parameters$included.multiplier.sd, n.obs)
                }
                
                inverse.multiplier.matrix = (1/included.multiplier.vector) %*% t(1/included.multiplier.vector)
                
                # AR.1 cannot be selected if we have year ranges because year ranges do not have distance measures
                if (private$i.parameters$included.multiplier.correlation.form == "autoregressive.1" && any(is.year.range(private$i.metadata$year)))
                    stop(paste0(error.prefix, "instructions cannot use 'autoregressive.1' for 'included.multiplier.correlation.form' since observations with year ranges were found"))

                multiplier.correlation.matrix = get_multiplier_correlation_matrix(rep(1, n.obs**2),
                                                                                  n.obs,
                                                                                  as.numeric(private$i.metadata$year),
                                                                                  private$i.parameters$included.multiplier.correlation,
                                                                                  private$i.parameters$included.multiplier.correlation.structure == "autoregressive.1")
                multiplier.covariance.matrix = multiplier.correlation.matrix * included.multiplier.sd.vector %*% t(included.multiplier.sd.vector)
                private$i.inverse.multiplier.matrix.times.cov.mat = inverse.multiplier.matrix * multiplier.covariance.matrix
            }
            ##

            ## ---- GENERATE INVERSE VARIANCE WEIGHTS MATRIX ---- ##
            private$i.metadata$stratum = as.character(private$i.metadata$stratum)
            private$i.inverse.variance.weights.matrix = generate.inverse.variance.weights.matrix(obs.vector = private$i.obs.vector,
                                                                                                 equalize.weight.by.year = instructions$equalize.weight.by.year,
                                                                                                 metadata = private$i.metadata,
                                                                                                 weights = private$i.weights)

        },
        check = function() {
            browser()
        }
    ),
    
    private = list(
        
        i.parameters = NULL,
        
        i.outcome.for.data = NULL,
        i.denominator.outcome.for.sim = NULL,
        i.outcome.is.proportion = NULL,

        i.obs.vector = NULL,
        i.details = NULL,
        i.metadata = NULL,
        i.sim.ontology = NULL,
        i.sim.required.dimnames = NULL,
        i.denominator.required.dimnames = NULL,
        i.sim.dimension.values = NULL,
        i.denominator.dimension.values = NULL,
        i.transformation.matrix = NULL,
        i.transformation.matrix.indices = NULL,
        i.transformation.matrix.row.oriented.indices = NULL,
        i.measurement.error.covariance.matrix = NULL,
        i.inverse.variance.weights.matrix = NULL,
        i.inverse.multiplier.matrix.times.cov.mat = NULL,
        
        i.dimension.values = NULL, # EXPERIMENTAL
        
        do.compute = function(sim, log, check.consistency, debug)
        {
            
            sim.numerator.data = sim$get(outcome = private$i.outcome.for.sim,
                                         keep.dimensions = names(private$i.sim.required.dimnames),
                                         dimension.values = private$i.sim.dimension.values,
                                         drop.single.sim.dimension = T,
                                         check.consistency = check.consistency)
            
            # if denom for sim is NULL, figure out if it's a proportion or not
            # if so, use a sim get requesting to get only the denominator
            use.poisson = is.null(private$i.denominator.outcome.for.sim && !private$i.outcome.is.proportion)
            if (use.poisson) {
                sim.denominator.data = numeric(0)
                expanded.sim.denominator.data = numeric(0)# so as not to throw errors in cpp sigma
            } else if (is.null(private$i.denominator.outcome.for.sim)) {
                sim.denominator.data = sim$get(outcome = private$ioutcome.for.sim,
                                               keep.dimensions = names(private$i.denominator.required.dimnames),
                                               dimension.values = private$i.denominator.dimension.values,
                                               output = 'denominator',
                                               drop.single.sim.dimension = T,
                                               check.consistency = check.consistency)
                expanded.sim.denominator.data = expand.array(sim.denominator.data, dimnames(sim.numerator.data))
            } else {
                sim.denominator.data = sim$get(outcome = private$i.denominator.outcome.for.sim,
                                               keep.dimensions = names(private$i.denominator.required.dimnames),
                                               dimension.values = private$i.denominator.dimension.values,
                                               drop.single.sim.dimension = T,
                                               check.consistency = check.consistency)
                expanded.sim.denominator.data = expand.array(sim.denominator.data, dimnames(sim.numerator.data))
            }
            
            # Re-purpose likelihood mean code to find aggregated N matrix (diagonal, so treated as vector)
            if (private$i.outcome.is.proportion) {
                n.vector = get_basic_likelihood_mean(expanded.sim.denominator.data,
                                                     private$i.transformation.matrix.row.oriented.indices,
                                                     length(private$i.obs.vector),
                                                     n.vector = numeric(length(private$i.obs.vector)))
            }
            
            # Warning! These don't throw an error when sim.numerator.data isn't long enough!
            mean = get_basic_likelihood_mean(sim.numerator.data,
                                             private$i.transformation.matrix.row.oriented.indices,
                                             length(private$i.obs.vector),
                                             mean = numeric(length(private$i.obs.vector))
            )
            
            sigma = get_basic_likelihood_sigma(sim.numerator.data,
                                               expanded.sim.denominator.data,
                                               private$i.transformation.matrix.indices,
                                               private$i.measurement.error.covariance.matrix,
                                               length(private$i.obs.vector),
                                               sigma = numeric(length(private$i.obs.vector) ^ 2), # maybe define before this?
                                               use.poisson
            )
            
            sigma = sigma * private$i.inverse.variance.weights.matrix
            
            # Revise sigma if including multiplier
            if (!is.null(private$i.inverse.multiplier.matrix.times.cov.mat)) {
                sigma = sigma + private$i.inverse.multiplier.matrix.times.cov.mat * (sigma + mean %*% t(mean))
            }
            
            if (private$i.outcome.is.proportion)
                likelihood = mvtnorm::dmvnorm(private$i.obs.vector * n.vector,
                                              mean = mean,
                                              sigma = matrix(sigma, nrow=length(private$i.obs.vector), ncol=length(private$i.obs.vector)),
                                              log=T,
                                              checkSymmetry = F)
            else
                likelihood = mvtnorm::dmvnorm(private$i.obs.vector,
                                              mean = mean,
                                              sigma = matrix(sigma, nrow=length(private$i.obs.vector), ncol=length(private$i.obs.vector)),
                                              log=T,
                                              checkSymmetry = F)
            
            if (debug) {
                lik.summary = cbind(private$i.metadata, obs=private$i.obs.vector, mean, sd=sqrt(diag(sigma)))
                browser()
            } 
            likelihood
            
            # verify.matrix.operation.correctness(sim.denominator.data,
            #                                     sim.numerator.data,
            #                                     private$i.transformation.matrix,
            #                                     private$i.measurement.error.covariance.matrix,
            #                                     private$i.inverse.variance.weights.matrix,
            #                                     private$i.obs.vector,
            #                                     likelihood,
            #                                     log)

            
        },
        
        generate.transformation.matrix = function(dimnames.list, remove.mask.list, n.strats, sim.dimnames)
        {
            transformation.matrix = NULL
            for (i in 1:n.strats) {
                
                one.dimnames = dimnames.list[[i]]
                one.remove.mask = remove.mask.list[[i]]
                
                years.in.sim.and.stratification = get.range.robust.year.intersect(one.dimnames$year, sim.dimnames$year)
                year.limited.dimnames = one.dimnames
                year.limited.dimnames$year = years.in.sim.and.stratification
                
                one.mapping = get.ontology.mapping(from.ontology = sim.dimnames, to.ontology = year.limited.dimnames[names(year.limited.dimnames) != 'source'])
                one.source.transformation.matrix = one.mapping$get.matrix(from.dim.names = sim.dimnames,
                                                                          to.dim.names = year.limited.dimnames[names(year.limited.dimnames) != 'source'])

                # Repeat the matrix for each source this stratification has
                one.transformation.matrix = NULL
                for (source in 1:length(one.dimnames$source)) one.transformation.matrix = rbind(one.transformation.matrix, one.source.transformation.matrix)
                ncol.mat = ncol(one.transformation.matrix)
                
                # Align the matrix rows with the one.remove.mask rows, which may have extra years, so that rows for sporadically missing data can be masked out
                years.in.stratification.but.not.sim = setdiff(one.dimnames$year, year.limited.dimnames$year)
                if (length(years.in.stratification.but.not.sim) > 0) {
                    indices.to.omit.from.one.remove.mask = get.array.access.indices(one.dimnames, list(year=years.in.stratification.but.not.sim))
                    new.one.remove.mask = one.remove.mask[-indices.to.omit.from.one.remove.mask]
                    one.transformation.matrix = one.transformation.matrix[!new.one.remove.mask,]
                } else
                    one.transformation.matrix = one.transformation.matrix[!one.remove.mask]
                one.transformation.matrix = matrix(one.transformation.matrix, ncol=ncol.mat)
                transformation.matrix = rbind(transformation.matrix, one.transformation.matrix)
            }
            transformation.matrix
        },
        
        generate.inverse.variance.weights.matrix = function(obs.vector,
                                                            equalize.weight.by.year,
                                                            metadata,
                                                            weights)
        {
            weights.vector = rep(1,length(obs.vector))

            if (equalize.weight.by.year) {
                obs.per.year = table(metadata$year)
                number.years = length(obs.per.year)
                
                for (year in names(obs.per.year)) {
                    weights.vector[metadata$year == year]  = length(obs.vector) / (obs.per.year[[year]] * number.years)
                }
            }
            
            stratum.names = lapply(metadata$stratum, function(x) {
                unlist(strsplit(x, "__"))
            })
            
            # Once the weights list is in the format list(weights.object1, weights.object2, ...), I'll loop over them.
            for (weight in weights) {
                
                # if no dimension.values, apply it to all observations
                if (length(weight$dimension.values) == 0) {
                    weights.vector = weights.vector * weight$total.weight
                } else {
                    weights.mask = sapply(stratum.names, function(x) {
                        contains.dimension.value = F
                        if (length(x) == length(weight$dimension.values)) {
                            for (d in seq_along(x)) {
                                # NOTE: This assumes the dimensions of the dimension.values are sorted alphabetically. The stratum names are.
                                if (x[[d]] %in% weight$dimension.values[[d]])
                                    contains.dimension.value = T
                                else {
                                    contains.dimension.value = F
                                    break
                                }
                            }
                        }
                        contains.dimension.value
                        
                    })
                    weights.vector[weights.mask] = weights.vector[weights.mask] * weight$total.weight
                }
            }
            
            sqrt.weights.vector = sqrt(1/weights.vector)
            sqrt.weights.vector %*% t(sqrt.weights.vector)
        },
        
        verify.matrix.operation.correctness = function(sim.denominator.data,
                                                       sim.numerator.data,
                                                       transformation.matrix,
                                                       measurement.error.covariance.matrix,
                                                       inverse.variance.weights.matrix,
                                                       obs.vector,
                                                       value.to.compare,
                                                       log)
        {
            sim.denominator.data = as.vector(sim.denominator.data)
            sim.numerator.data = as.vector(sim.numerator.data)

            transformed.numerator.data = transformation.matrix %*% sim.numerator.data

            model.imperfection.error.variance =
                sim.numerator.data * (1 - sim.numerator.data / sim.denominator.data)
            model.imperfection.error.covariance.matrix = diag(model.imperfection.error.variance, nrow=length(model.imperfection.error.variance), ncol=length(model.imperfection.error.variance))

            transformed.model.imperfection.error.covariance.matrix =
                transformation.matrix %*%
                model.imperfection.error.covariance.matrix %*%
                t(transformation.matrix)

            # sigma
            overall.covariance.matrix = measurement.error.covariance.matrix + transformed.model.imperfection.error.covariance.matrix
            overall.covariance.matrix = overall.covariance.matrix * inverse.variance.weights.matrix
            computed.value=mvtnorm::dmvnorm(obs.vector,
                                            mean = transformed.numerator.data,
                                            sigma = overall.covariance.matrix,
                                            log=log,
                                            checkSymmetry = F)
            if (computed.value == value.to.compare)
                print("Outputs match")
            else
                print("Outputs do not match")
        }
    )
)